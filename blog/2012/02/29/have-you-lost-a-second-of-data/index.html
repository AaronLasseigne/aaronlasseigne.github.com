
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Have you lost a second of data? - ficate</title>
  <meta name="author" content="Aaron Lasseigne">

  
  <meta name="description" content="UPDATE: Based on some good Reddit discussions I&#8217;ve revised the &#8220;Only use ranges.&#8221; section to use a range with an exclusive end. One &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://AaronLasseigne.github.com/blog/2012/02/29/have-you-lost-a-second-of-data">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="ficate" type="application/atom+xml">
  <link href='http://fonts.googleapis.com/css?family=IM+Fell+Great+Primer+SC' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Actor' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-28492927-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">ficate</a> [fiâ€¢cate]</h1>
  
    <div class="subtitle">verb<p>To make, build, do.</p></div>
  
</hgroup>

</header>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">Have you lost a second of data?</h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-02-29T15:42:00Z" pubdate data-updated="true">2012.02.29 @ 03:42 pm UTC</time>
        
      </p>
    
  </header>


<div class="entry-content"><p><strong>UPDATE:</strong> Based on some good <a href="http://www.reddit.com/r/rails/comments/qberl/have_you_lost_a_second_of_data/">Reddit</a> discussions I&#8217;ve revised the &#8220;Only use ranges.&#8221; section to use a range with an exclusive end.</p>

<p>One of the gems I&#8217;m working on limits a range of data based on a datetime field. I use a SQLite database (version 3.7.7) in my automated testing, but ultimately it&#8217;s going to run on MySQL (version 5.5.19) and possibly others. The ease of SQLite makes this a fairly common setup. ActiveRecord (version 3.2.1) helps alleviate cross database issues but it doesn&#8217;t cover all cases. You see MySQL stores datetimes to a resolution of one second. Databases like SQLite and PostgreSQL store down to the microsecond (.999999). This leads to a problem.</p>

<h3>The Problem</h3>

<p>If, like me, the bulk of your time has been spent working with MySQL then microseconds may seem reasonable but foreign. A typical ActiveRecord <code>where</code> call would give you all results from within a second. In SQLite that same call gives results from the exact microsecond specified.</p>

<!-- more -->




<figure class='code'> <div class="highlight"><table><tr><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&gt;</span> <span class="no">Test</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">created_at</span><span class="p">:</span> <span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;2012-01-01 00:00:01&#39;</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># MySQL</span>
</span><span class='line'><span class="no">SELECT</span> <span class="s2">&quot;tests&quot;</span><span class="o">.</span><span class="n">*</span> <span class="no">FROM</span> <span class="s2">&quot;tests&quot;</span> <span class="no">WHERE</span> <span class="s2">&quot;tests&quot;</span><span class="o">.</span><span class="s2">&quot;created_at&quot;</span> <span class="o">=</span> <span class="s1">&#39;2012-01-01 06:00:01&#39;</span>
</span><span class='line'><span class="mi">4</span> <span class="no">Results</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># SQLite</span>
</span><span class='line'><span class="no">SELECT</span> <span class="s2">&quot;tests&quot;</span><span class="o">.</span><span class="n">*</span> <span class="no">FROM</span> <span class="s2">&quot;tests&quot;</span> <span class="no">WHERE</span> <span class="s2">&quot;tests&quot;</span><span class="o">.</span><span class="s2">&quot;created_at&quot;</span> <span class="o">=</span> <span class="s1">&#39;2012-01-01 06:00:01.000000&#39;</span>
</span><span class='line'><span class="mi">1</span> <span class="no">Result</span>
</span></code></pre></td></tr></table></div></figure>


<p>Searching for a single second isn&#8217;t too common. How about all records from a particular day?</p>

<figure class='code'> <div class="highlight"><table><tr><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&gt;</span> <span class="no">Test</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">created_at</span><span class="p">:</span> <span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;2012-01-01 00:00:00&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">.</span><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;2012-01-01 23:59:59&#39;</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>In databases that measure microseconds you&#8217;re going to be missing any information that occurred between &#8220;23:59:59.000000&#8221; and &#8220;23:59:59.999999&#8221;. You&#8217;ve missed almost a full second of data. What if your ecommerce site made a sale in that one second?</p>

<h3>Solutions</h3>

<p>So, how do we handle this?</p>

<h4>Build to the database you&#8217;re using.</h4>

<p>This is the most common route when building applications. Only one brand of database is used and if it changes the process won&#8217;t be seamless anyway. What&#8217;s one more to-do item on the database migration checklist? Additionally, costs are deferred until you switch databases which may never occur. It&#8217;s not an ideal option, but it&#8217;s a realistic one. For those writing publicly available gems, limiting your support limits your audience.</p>

<h4>Chop all microseconds off and store everything to only a one second resolution.</h4>

<p>I hate to lose data. It may not matter to your application now but you can never get it back. If you&#8217;re authoring a public gem this might get you lynched.</p>

<h4>Use the &#8220;%&#8221; wildcard.</h4>

<p>You could do something with <code>LIKE</code> and string conversion where the &#8220;%&#8221; wildcard is used at the end of a datetime string. It might be a clever idea but it breaks if you&#8217;re working with time zones. It&#8217;s best to avoid this approach.</p>

<h4>Customize for each database.</h4>

<p>Embrace the differences by adding conditionals to alter the code depending on the database adapter in use (<code>ActiveRecord::Base.connection.class</code>). Most databases record some fraction of a second, MySQL is the odd one out. Providing a special case for MySQL and handling the rest with a default should work. When writing a public gem, it&#8217;s hard to go wrong with this approach. In applications it&#8217;ll clutter things up significantly to do this everywhere. Make sure to create global scopes, helpers, etc to <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a> it up.</p>

<h4>Only use ranges.</h4>

<p>One last solution is to stick with ranges. Notice in the example below that the range excludes the end value (3 dots rather than 2).</p>

<figure class='code'> <div class="highlight"><table><tr><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&gt;</span> <span class="n">datetime</span> <span class="o">=</span> <span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;2012-01-01&#39;</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;</span> <span class="no">Test</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">created_at</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">advance</span><span class="p">(</span><span class="n">days</span><span class="p">:</span> <span class="mi">1</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># MySQL</span>
</span><span class='line'><span class="no">SELECT</span> <span class="s2">&quot;tests&quot;</span><span class="o">.</span><span class="n">*</span> <span class="no">FROM</span> <span class="s2">&quot;tests&quot;</span> <span class="no">WHERE</span> <span class="p">(</span><span class="s2">&quot;tests&quot;</span><span class="o">.</span><span class="s2">&quot;created_at&quot;</span> <span class="o">&gt;=</span> <span class="s1">&#39;2012-01-01 00:00:00&#39;</span> <span class="no">AND</span> <span class="s2">&quot;testers&quot;</span><span class="o">.</span><span class="s2">&quot;created_at&quot;</span> <span class="o">&lt;</span> <span class="s1">&#39;2012-01-02 00:00:00&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># SQLite</span>
</span><span class='line'><span class="no">SELECT</span> <span class="s2">&quot;tests&quot;</span><span class="o">.</span><span class="n">*</span> <span class="no">FROM</span> <span class="s2">&quot;tests&quot;</span> <span class="no">WHERE</span> <span class="p">(</span><span class="s2">&quot;tests&quot;</span><span class="o">.</span><span class="s2">&quot;created_at&quot;</span> <span class="o">&gt;=</span> <span class="s1">&#39;2012-01-01 00:00:00.000000&#39;</span> <span class="no">AND</span> <span class="s2">&quot;testers&quot;</span><span class="o">.</span><span class="s2">&quot;created_at&quot;</span> <span class="o">&lt;</span> <span class="s1">&#39;2012-01-02 00:00:00.000000&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>That retrieves the entire days data in both MySQL and SQLite. The <code>advance</code> function includes a variety of increments ranging from seconds to years. Using an exclusive end rather than inclusive helps to avoid another pitfall, leap seconds. When needed, leap seconds are added at the end of the day. Inclusive searches to &#8216;23:59:59.999999&#8217; aren&#8217;t going to catch that extra second.</p>

<h3>Conclusion</h3>

<p>One day ActiveRecord might handle these differences, but for now using per database conditionals or sticking to ranges will have to do. It&#8217;s worth noting that the amount of fractional time stored does vary. Some databases even allow you to specify a precision. If you know of a better way to tackle this problem drop a comment below. Let&#8217;s find those missing seconds.</p>
</div>


  <footer>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://AaronLasseigne.github.com/blog/2012/02/29/have-you-lost-a-second-of-data/" data-via="AaronLasseigne" data-counturl="http://AaronLasseigne.github.com/blog/2012/02/29/have-you-lost-a-second-of-data/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2012/01/17/explaining-include-and-extend/" title="Previous Post: Explaining Include and Extend">&laquo; Explaining Include and Extend</a>
      
      
    </p>
  </footer>
</article>

</div>

    </div>
  </div>
  
  <aside class="sidebar">
    
      <section id="about">
  <h3>Aaron Lasseigne</h3>
  <img width="75" height="75" alt="" src="/images/me.jpg">
  <p>Ruby developer, gin drinker, football watcher, husband and new father.</p>
  <br / style="clear: both;">
  
  gh: <a href="https://github.com/AaronLasseigne">AaronLasseigne</a><br/>
  
  so: <a href="http://stackoverflow.com/users/1016794/aaron-lasseigne">Aaron Lasseigne</a><br/>
  
  tw: <a href="http://twitter.com/AaronLasseigne">@AaronLasseigne</a><br/>
  
</section>
<section id="projects">
  <h3>Projects</h3>
  <dl>
    <dt>
      <a href="https://github.com/orgsync/jquery-aria">jquery-aria</a> <em>jquery</em>
    </dt>
    <dd>A jQuery plugin that adds support for ARIA attributes.</dd>
    <dt>
      <a href="https://github.com/AaronLasseigne/tableficate">tableficate</a> <em>rails</em>
    </dt>
    <dd>A DSL for Rails that provides easy table creation with sorting and filtering.</dd>
    <dt>
      <a href="https://github.com/AaronLasseigne/with_filters">with_filters</a> <em>rails</em>
    <dd>Add filtering to tables, lists, etc.</dd>
    <dt>
      <a href="https://github.com/AaronLasseigne/with_order">with_order</a> <em>rails</em>
    </dt>
    <dd>Provide ordering for tables, lists, etc.</dd>
  </dl>
</section>

    
  </aside>
  
  <footer role="contentinfo">Copyright &copy; 2012

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
